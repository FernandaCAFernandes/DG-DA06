15/07/23
Unidade 2 - EXTRA√á√ÉO, TRANSFORMA√á√ÉO E CARGA (ETL)	


M√≥dulo 1 - Processo de descoberta de conhecimento

Ler a apostila, dica seria come√ßar a ler de tr√°s para frente.

A sigla KDD √©  Knowledge Discovery in Databases.Esse processo envolve sele√ß√£o, pr√©-processamento, transforma√ß√£o e minera√ß√£o de dados. Essa t√©cnica auxilia no processo de extra√ß√£o e descobertas de informa√ß√µes valiosas em grandes volumes de dados. 
As etapas do KDD s√£o:
Sele√ß√£o de dados: Pegar a fonte de dados com a qual se deseja trabalhar. Pode-se utilizar os dados parciais, uma amostra ou o dado completo. 
Pr√©-processamento: Tratamento que ser√° realizado em cima do dado, como limpeza dos dados, transforma√ß√µes (altera√ß√µes na formata√ß√£o das colunas) e enriquecimento e redu√ß√£o de dados, que seria a retirada em si dos dados. 
Obs: Quando h√° muitos nulos, uma op√ß√£o √© utilizar machine learning para realizar previs√µes do que poderiam ser valores adequados para realizar o tratamento e preenchimento de nulos. 
Transforma√ß√£o: Muito utilizado na parte de machine learning, s√£o feitas as opera√ß√µes de normaliza√ß√£o, discretiza√ß√£o, agrega√ß√£o e redu√ß√£o dos dados.
Minera√ß√£o de dados: Visualiza√ß√£o de dados, √°rvores de decis√£o, clusteriza√ß√£o.
Avalia√ß√£o de padr√µes: Localizar e selecionar padr√µes, verificar a validade dos padr√µes encontrados, e finalmente, a compreens√£o dos significados e infer√™ncias dos padr√µes encontrados. 
Obs: Para esse curso, as etapas que s√£o de vital import√¢ncia s√£o a etapa de sele√ß√£o, o pr√©-processamento e a transforma√ß√£o. Com foco nas duas primeiras etapas mencionadas. 

CRISP-DM significa Cross Industry Standard Process for Data Mining, e √© uma
metodologia de minera√ß√£o de dados. Ambos s√£o modelos de minera√ß√£o de dados, por√©m ressalta-se que o CRISP-DM √© mais utilizado do que o KDD.
O CRISP-DM parece ser similar a ideia do SCRUM, no qual as etapas das atividades s√£o bem divididas e o foco √© em fazer entregas pequenas ao longo do per√≠odo de dura√ß√£o da atividade com o intuito de sempre buscar feedback para que a entrega final esteja de acordo com o que √© desejado pelo cliente/usu√°rio. No CRISP-DM nas fases de Data Understanding, Data Preparation e Modeling √© onde encontra-se o ETL. 

Existe o ETL e tamb√©m o ELT. No caso ambos representam o mesmo processo, por√©m a fase que diz respeito ao loading acontece em etapas diferentes. No caso do ETL, o loading acontece ap√≥s toda a fase da transforma√ß√£o ter acontecido e ser finalizada, enquanto isso no ELT a fase de loading ir√° acontecer antes da fase de transforma√ß√£o. 
Obs: ETL normalmente √© utilizado pelo cientista, enquanto o ELT √© normalmente utilizado pelo analista.




Anexo ü¶ä:
Data Lakes √© um reposit√≥rio centralizado projetado para armazenar, processar e proteger grandes quantidades de dados estruturados, semiestruturados e n√£o estruturados. Ele pode armazenar dados em seu formato nativo e processar qualquer variedade desses dados, ignorando os limites de tamanho. Ou seja, ele recebe uma grande quantidade de dados das mais diversas fontes. 
O Data Lake possui tr√™s camadas distintas, sendo elas:]
A camada Bronze, a camada que ir√° receber todos os dados que far√£o parte do Data Lake. 
A camada Prata, essa camada recebe os dados que est√£o na camada Bronze, por√©m apenas quando os dados j√° est√£o pr√©-processados. 
A camada Ouro ir√° conter os dados j√° tratados que basicamente est√£o preparados para que seja gerado visualiza√ß√µes com os mesmos.  
Obs: Em alguns casos o DW √© criado ou na camada Prata ou na Ouro, cria-se dentro do Data Lake, no geral, para manter os dados centralizados, por√©m tamb√©m acontece de na pr√°tica empresas montarem o DW totalmente fora do Data Lake.

üè† Atividade de 8/07 para 15/07 

SQL (Structured Query Language) e NoSQL (Not Only SQL) s√£o duas abordagens diferentes de armazenamento e manipula√ß√£o de dados em bancos de dados. O SQL foi desenvolvido na d√©cada de 1970 pelos pesquisadores da IBM Donald D. Chamberlin e Raymond F. Boyce, e  foi projetado para ser uma linguagem padr√£o de consulta para bancos de dados relacionais, que representam os dados em tabelas com linhas e colunas. Seu principal objetivo era fornecer uma maneira declarativa e eficiente de recuperar, inserir, atualizar e excluir dados.
O SQL  apresenta algumas vantagens, sendo elas: 
Estrutura bem definida: O modelo relacional permite que os dados sejam organizados em tabelas com relacionamentos bem definidos, garantindo integridade referencial e consist√™ncia.
Suporte ACID: Os bancos de dados relacionais seguem o conceito ACID (Atomicidade, Consist√™ncia, Isolamento, Durabilidade), garantindo a seguran√ßa e a confiabilidade das transa√ß√µes.
Maturidade e comunidade: O SQL tem sido amplamente utilizado h√° d√©cadas, resultando em uma comunidade bem estabelecida, muitas ferramentas e uma grande quantidade de documenta√ß√£o dispon√≠vel.

Enquanto isso, em rela√ß√£o √† desvantagens, podemos citar: 
Escalabilidade horizontal limitada: O modelo relacional tradicional pode enfrentar desafios ao lidar com grandes volumes de dados e escalabilidade horizontal em ambientes distribu√≠dos.
Esquema r√≠gido: O esquema de banco de dados relacional √© inflex√≠vel, exigindo modifica√ß√µes cuidadosas quando h√° mudan√ßas nos requisitos de dados.

O termo NoSQL foi criado no final dos anos 90, mas o movimento NoSQL ganhou impulso em meados de 2009. Adicionalmente, o NoSQL foi criado para atender aos desafios enfrentados pelos bancos de dados relacionais em rela√ß√£o √† escalabilidade, flexibilidade de esquema e capacidade de lidar com dados n√£o estruturados ou semiestruturados.
Os bancos de dados que se utilizam de NoSQL podem ser subdivididos em diversos tipos, sendo eles:
Armazenamento de Documentos: Esses bancos armazenam dados em formatos JSON, BSON ou similares, onde cada registro (documento) pode ter uma estrutura diferente. Exemplos incluem MongoDB e Couchbase.
Armazenamento Chave-Valor: Esses bancos armazenam dados como pares de chave-valor, onde a chave √© um identificador √∫nico e o valor √© o dado associado. Exemplos incluem Redis e Amazon DynamoDB
Armazenamento de Fam√≠lia de Colunas: Tamb√©m conhecidos como Wide-Column Stores, esses bancos de dados organizam os dados em fam√≠lias de colunas ou fam√≠lias de colunas com linhas. Cada linha pode ter colunas diferentes, e cada coluna cont√©m v√°rias vers√µes do dado. Exemplos incluem Apache Cassandra e HBase.
Bancos de Dados de Grafos: Esses bancos de dados s√£o projetados para armazenar e representar dados na forma de um grafo, composto por n√≥s (v√©rtices) e arestas (relacionamentos). S√£o √∫teis para estruturas de dados complexas e dados com muitos relacionamentos. Exemplos incluem Neo4j e Amazon Neptune.
Bancos de Dados de S√©ries Temporais: Esses bancos de dados s√£o otimizados para lidar com dados de s√©ries temporais, como leituras de sensores, dados financeiros e registros de servidores. Exemplos incluem InfluxDB e Prometheus.
Bancos de Dados de Objetos: Esses bancos armazenam dados na forma de objetos, semelhante ao que ocorre em linguagens de programa√ß√£o orientadas a objetos. S√£o √∫teis para aplicativos que utilizam fortemente paradigmas orientados a objetos. Exemplos incluem ZopeDB e ObjectDB.
Bancos de Dados XML: Esses bancos de dados s√£o projetados para armazenar e consultar dados XML. S√£o √∫teis para aplicativos que dependem fortemente de formatos de dados XML. Exemplos incluem BaseX e eXist-db.
(Bancos de Dados Colunares: Esses bancos de dados armazenam dados em colunas em vez de linhas, o que pode levar a melhor compress√£o e desempenho de consulta mais r√°pido para determinadas cargas de trabalho. Exemplos incluem Apache Parquet e ClickHouse.
Bancos de Dados NewSQL: Embora n√£o sejam estritamente NoSQL, os bancos de dados NewSQL t√™m como objetivo combinar as melhores caracter√≠sticas dos bancos de dados SQL tradicionais com a escalabilidade e flexibilidade dos bancos de dados NoSQL. Exemplos incluem CockroachDB e TiDB.

De maneira geral, podemos elencar as vantagens do NoSQL como sendo:
Escalabilidade horizontal: Os bancos de dados NoSQL, como o Cassandra e o MongoDB, s√£o projetados para escalabilidade horizontal e podem lidar com grandes quantidades de dados distribu√≠dos em v√°rios servidores.
Esquema flex√≠vel: NoSQL permite que os dados sejam armazenados sem um esquema r√≠gido, o que facilita mudan√ßas nos requisitos de dados e o armazenamento de dados n√£o estruturados.
Alta velocidade: Alguns bancos de dados NoSQL s√£o otimizados para consultas e opera√ß√µes de leitura/grava√ß√£o r√°pidas, ideais para aplicativos com alto volume de acesso a dados.

Enquanto isso suas desvantagens s√£o: 
Consist√™ncia eventual: Alguns sistemas NoSQL priorizam a disponibilidade e a escalabilidade em detrimento da consist√™ncia imediata dos dados, o que pode levar a algumas inconsist√™ncias tempor√°rias.
Falta de padr√µes e ferramentas consolidadas: O movimento NoSQL √© relativamente novo em compara√ß√£o com o SQL, e, como resultado, pode haver uma variedade de op√ß√µes, mas nem todas t√™m ferramentas e padr√µes consolidados.

Apesar de suas diferen√ßas, com vantagens e desvantagens distintas, no que diz respeito √† qual tipo de database deve ser utilizado varia para cada caso de uso. No caso do SQL, sua utiliza√ß√£o √© mais adequada para, por exemplo aplica√ß√µes com requisitos de transa√ß√µes complexas e consistentes, como sistemas financeiros, situa√ß√µes em que o esquema dos dados √© est√°vel e bem definido desde o in√≠cio ou mesmo aplica√ß√µes que exigem recursos de ACID para garantir a integridade dos dados.
Enquanto, o NoSQL tamb√©m se prova como sendo a melhor escolha em situa√ß√µes como quando √† aplica√ß√µes com necessidades de escalabilidade horizontal e distribui√ß√£o de dados, ou situa√ß√µes em que a flexibilidade do esquema √© importante devido √† natureza evolutiva dos dados, ou at√© mesmo quando aplica√ß√µes com alto volume de leitura/grava√ß√£o, como aplicativos web e m√≥veis.



üè† Atividade de 15/07 para 22/07 
Desenhar qual seria a arquitetura ideal para o nosso DB, levando em considera√ß√£o o DW.
Qual seria a arquitetura ideal para o nosso DB? Qual a melhor solu√ß√£o?
Obs: Dica seria ter duas m√°quinas diferentes com o DB (Ambos postgresql ou diferentes DB SQL), al√©m disso, poder√≠amos ter o DB em si e o DW em m√°quinas diferentes tamb√©m, sendo o DW em particular jogado para cloud.  

